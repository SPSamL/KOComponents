import ko from 'knockout';
import Context from './context';
import Route from './route';
import {isBool, isUndefined} from './utils';
var events = {
    click: document.ontouchstart ? 'touchstart' : 'click',
    popstate: 'popstate'
};
var onInit = [];
var routers = [];
var Router = function Router(params) {
    var this$1 = this;

    this.component = ko.observable();
    this.isNavigating = ko.observable(true);
    this.routes = Route.createRoutes(params.routes || {});
    Router.link(this);
    if (this.isRoot) {
        Router.setConfig(params);
        (ref = this.routes).push.apply(ref, Route.createRoutes(Router.routes));
        document.addEventListener(events.click, Router.onclick);
        window.addEventListener(events.popstate, Router.onpopstate);
    } else if (this.$parent.ctx.route.children) {
        (ref$1 = this.routes).push.apply(ref$1, this.$parent.ctx.route.children);
    }
    this.passthrough = Object.entries(params).reduce(function (accum, ref) {
        var k = ref[0];
        var v = ref[1];

        return k === 'base' || k === 'hashbang' || k === 'routes' ? accum : Object.assign(accum, ( obj = {}, obj[k] = v, obj ))
        var obj;;
    }, {});
    this.update(this.getPathFromLocation(), false).then(function () { return onInit.forEach(function (r) { return r(this$1); }); });
    var ref;
    var ref$1;
};

var prototypeAccessors = { base: {},$parent: {},$parents: {},$child: {},$children: {} };
var staticAccessors = { head: {},tail: {},initialized: {} };
prototypeAccessors.base.get = function () {
    return this.isRoot ? Router.config.base + (Router.config.hashbang ? '/#!' : '') : this.$parent.base + this.$parent.ctx.pathname;
};
prototypeAccessors.$parent.get = function () {
    return routers[this.depth - 1];
};
prototypeAccessors.$parents.get = function () {
    return routers.slice(0, this.depth).reverse();
};
prototypeAccessors.$child.get = function () {
    return routers[this.depth + 1];
};
prototypeAccessors.$children.get = function () {
    return routers.slice(this.depth + 1);
};
Router.prototype.update = function update (url, args) {
    return new Promise((function ($return, $error) {
        var fromCtx, search, hash, path, route, params, pathname, childPath, shouldNavigate, toCtx, fromCtxChildren;
        fromCtx = this.ctx;
        if (isBool(args)) {
            args = {
                push: args
            };
        } else if (isUndefined(args)) {
            args = {};
        }
        if (isUndefined(args.push)) {
            args.push = true;
        }
        if (isUndefined(args.with)) {
            args.with = {};
        }
        var assign;
            ((assign = Router.parseUrl(url), search = assign.search, hash = assign.hash));
        path = Router.getPath(url);
        route = this.resolveRoute(path);
        if (!route) {
            return $return(false);
        }
        var assign$1;
            (assign$1 = route.parse(path), params = assign$1[0], pathname = assign$1[1], childPath = assign$1[2]);
        if (fromCtx && fromCtx.pathname === pathname && !args.force) {
            if (this.$child) {
                return this.$child.update(childPath + search + hash, args).then($return, $error);
            } else {
                return $return(false);
            }
            return $If_1.call(this);
        }
        function $If_1() {
            if (fromCtx) {
                return fromCtx.runBeforeNavigateCallbacks().then((function ($await_10) {
                    try {
                        shouldNavigate = $await_10;
                        if (shouldNavigate === false) {
                            return $return(false);
                        }
                        this.isNavigating(true);
                        return $If_2.call(this);
                    } catch ($boundEx) {
                        return $error($boundEx);
                    }
                }).bind(this), $error);
            }
            function $If_2() {
                history[args.push ? 'pushState' : 'replaceState'](history.state, document.title, this.base + path + search + hash);
                toCtx = new Context(Object.assign({}, args.with, this.passthrough, {
                    router: this,
                    params: params,
                    route: route,
                    path: path,
                    pathname: pathname
                }));
                if (fromCtx) {
                    return fromCtx.runBeforeDispose().then((function ($await_11) {
                        try {
                            return $If_3.call(this);
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }).bind(this), $error);
                }
                function $If_3() {
                    fromCtxChildren = fromCtx && fromCtx.$children.reverse();
                    return toCtx.runBeforeRender().then((function ($await_12) {
                        try {
                            this.ctx = toCtx;
                            this.component(false);
                            ko.tasks.runEarly();
                            this.component(this.ctx.route.component);
                            ko.tasks.runEarly();
                            if (fromCtx) {
                                {
                                    var fromCtxChild, $iterator_fromCtxChild_5 = [fromCtxChildren[Symbol.iterator]()];
                                    var $Loop_6_trampoline;
                                    return ($Loop_6_trampoline = (function (q) {
                                            var this$1 = this;

                                        while (q) {
                                            if (q.then) 
                                                { return void q.then($Loop_6_trampoline, $error); }
                                            try {
                                                if (q.pop) 
                                                    { if (q.length) 
                                                    { return q.pop() ? $Loop_6_exit.call(this$1) : q; }
                                                 else 
                                                    { q = $Loop_6; } }
                                                 else 
                                                    { q = q.call(this$1); }
                                            } catch (_exception) {
                                                return $error(_exception);
                                            }
                                        }
                                    }).bind(this))($Loop_6);
                                    function $Loop_6() {
                                        if (!($iterator_fromCtxChild_5[1] = $iterator_fromCtxChild_5[0].next()).done && ((fromCtxChild = $iterator_fromCtxChild_5[1].value) || true)) {
                                            return fromCtxChild.runAfterDispose().then((function ($await_13) {
                                                try {
                                                    return $Loop_6;
                                                } catch ($boundEx) {
                                                    return $error($boundEx);
                                                }
                                            }).bind(this), $error);
                                        } else 
                                            { return [1]; }
                                    }
                                        
                                }
                                function $Loop_6_exit() {
                                    return fromCtx.runAfterDispose().then((function ($await_14) {
                                        try {
                                            return $If_4.call(this);
                                        } catch ($boundEx) {
                                            return $error($boundEx);
                                        }
                                    }).bind(this), $error);
                                }
                                    
                            }
                            function $If_4() {
                                return toCtx.runAfterRender().then((function ($await_15) {
                                    try {
                                        this.isNavigating(false);
                                        return $return(true);
                                    } catch ($boundEx) {
                                        return $error($boundEx);
                                    }
                                }).bind(this), $error);
                            }
                                
                            return $If_4.call(this);
                        } catch ($boundEx) {
                            return $error($boundEx);
                        }
                    }).bind(this), $error);
                }
                    
                return $If_3.call(this);
            }
                
            return $If_2.call(this);
        }
            
        return $If_1.call(this);
    }).bind(this));
};
Router.prototype.resolveRoute = function resolveRoute (path) {
        var this$1 = this;

    var matchingRouteWithFewestDynamicSegments;
    var fewestMatchingSegments = Infinity;
    for (var rn in this$1.routes) {
        var r = this$1.routes[rn];
        if (r.matches(path)) {
            if (r._keys.length === 0) {
                return r;
            } else if (fewestMatchingSegments === Infinity || r._keys.length < fewestMatchingSegments && r._keys[0].pattern !== '.*') {
                fewestMatchingSegments = r._keys.length;
                matchingRouteWithFewestDynamicSegments = r;
            }
        }
    }
    return matchingRouteWithFewestDynamicSegments;
};
Router.prototype.getPathFromLocation = function getPathFromLocation () {
    var path = location.pathname + location.search + location.hash;
    var baseWithOrWithoutHashbangRegexp = this.base.replace('#!', '#?!?');
    return path.replace(new RegExp(baseWithOrWithoutHashbangRegexp, 'i'), '');
};
Router.prototype.dispose = function dispose () {
        var this$1 = this;

    Router.unlink();
    if (this.isRoot) {
        document.removeEventListener(events.click, Router.onclick, false);
        window.removeEventListener(events.popstate, Router.onpopstate, false);
        this.ctx.runBeforeDispose().then(function () { return this$1.ctx.runAfterDispose(); });
    }
};
Router.setConfig = function setConfig (ref) {
        var base = ref.base;
        var hashbang = ref.hashbang;

    if (base) {
        Router.config.base = base;
    }
    if (hashbang) {
        Router.config.hashbang = hashbang;
    }
};
Router.use = function use () {
        var fns = [], len = arguments.length;
        while ( len-- ) fns[ len ] = arguments[ len ];

    (ref = Router.middleware).push.apply(ref, fns);
        var ref;
};
Router.usePlugin = function usePlugin () {
        var fns = [], len = arguments.length;
        while ( len-- ) fns[ len ] = arguments[ len ];

    (ref = Router.plugins).push.apply(ref, fns);
        var ref;
};
Router.useRoutes = function useRoutes (routes) {
    Object.assign(Router.routes, routes);
};
Router.get = function get (i) {
    return routers[i];
};
staticAccessors.head.get = function () {
    return routers[0];
};
staticAccessors.tail.get = function () {
    return routers[routers.length - 1];
};
staticAccessors.initialized.get = function () {
    if (routers.length === 0) {
        return new Promise(function (resolve) { return onInit.push(resolve); });
    } else {
        return Promise.resolve(Router.head);
    }
};
Router.update = function update () {
        var args = [], len = arguments.length;
        while ( len-- ) args[ len ] = arguments[ len ];

    return new Promise((function ($return, $error) {
        return (ref = routers[0]).update.apply(ref, args).then($return, $error);
            var ref;
    }).bind(this));
};
Router.link = function link (router) {
    router.depth = routers.length;
    router.isRoot = router.depth === 0;
    routers.push(router);
    router.$root = routers[0];
};
Router.unlink = function unlink () {
    routers.pop();
};
Router.onclick = function onclick (e) {
    if (e.defaultPrevented) {
        return;
    }
    var el = e.target;
    while (el && 'A' !== el.nodeName) {
        el = el.parentNode;
    }
    if (!el || 'A' !== el.nodeName) {
        return;
    }
    var pathname = el.pathname;
        var search = el.search;
        var hash = el.hash; if ( hash === void 0 ) hash = '';
    var path = (pathname + search + hash).replace(new RegExp(routers[0].base, 'i'), '');
    var isValidRoute = Router.hasRoute(path);
    var isCrossOrigin = !Router.sameOrigin(el.href);
    var isDoubleClick = 1 !== Router.which(e);
    var isDownload = el.hasAttribute('download');
    var isEmptyHash = el.getAttribute('href') === '#';
    var isMailto = (el.getAttribute('href') || '').indexOf('mailto:') === 0;
    var hasExternalRel = el.getAttribute('rel') === 'external';
    var hasModifier = e.metaKey || e.ctrlKey || e.shiftKey;
    var hasOtherTarget = el.hasAttribute('target');
    if (!isValidRoute || isCrossOrigin || isDoubleClick || isDownload || isEmptyHash || isMailto || hasExternalRel || hasModifier || hasOtherTarget) {
        return;
    }
    Router.update(path);
    e.preventDefault();
};
Router.onpopstate = function onpopstate (e) {
    Router.update(routers[0].getPathFromLocation(), false);
    e.preventDefault();
};
Router.canonicalizePath = function canonicalizePath (path) {
    return path.replace(new RegExp('/?#?!?/?'), '/');
};
Router.parseUrl = function parseUrl (url) {
    var parser = document.createElement('a');
    var b = routers[0].base.toLowerCase();
    if (b && url.toLowerCase().indexOf(b) === 0) {
        url = url.replace(new RegExp(b, 'i'), '') || '/';
    }
    parser.href = Router.canonicalizePath(url);
    return {
        hash: parser.hash,
        pathname: parser.pathname.charAt(0) === '/' ? parser.pathname : '/' + parser.pathname,
        search: parser.search
    };
};
Router.getPath = function getPath (url) {
    return Router.parseUrl(url).pathname;
};
Router.hasRoute = function hasRoute (path) {
    return !isUndefined(Router.head.resolveRoute(Router.getPath(path)));
};
Router.sameOrigin = function sameOrigin (href) {
    var hostname = location.hostname;
        var port = location.port;
        var protocol = location.protocol;
    var origin = protocol + '//' + hostname;
    if (port) {
        origin += ':' + port;
    }
    return href && href.indexOf(origin) === 0;
};
Router.which = function which (e) {
    e = e || window.event;
    return null === e.which ? e.button : e.which;
};

Object.defineProperties( Router.prototype, prototypeAccessors );
Object.defineProperties( Router, staticAccessors );
Router.config = {
    base: '',
    hashbang: false
};
Router.middleware = [];
Router.plugins = [];
Router.routes = {};
export default Router


